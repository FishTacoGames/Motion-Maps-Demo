#pragma kernel CSMain

RWTexture2DArray<float4> ResultArray;
StructuredBuffer<float4> positionValues; // Object positions (x, y, z, direction float)
StructuredBuffer<float4> motionValues;   // Motion strengths; (red, height, length, width)
StructuredBuffer<float4> sliceOrigins;
int cellSize;
int textureSize; 
uint indexToClear;
    // Maps positions to texture space using origins and texture res
[numthreads(8, 8, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    float4 origin = sliceOrigins[id.z];
    float pixelSize = (float)cellSize / (float)textureSize;
    float2 pixelWorldPos = origin.xz - float2(cellSize * 0.5, cellSize * 0.5) + float2(id.x * pixelSize, id.y * pixelSize);

    float4 color = ResultArray[uint3(id.xyz)];

    // Clear the slice?
    if (indexToClear == id.z)
    {
        color = float4(0.0, 0.0, 0.0, 1.0);
        ResultArray[uint3(id.xyz)] = color;
        return;
    }

    // Fade over time retaining y values
    color = lerp(color, float4(0.0, color.y, 0.0, color.a), 0.00025);

    for (uint i = 0; i < positionValues.Length; i++)
    {
        float2 offset = pixelWorldPos - positionValues[i].xz;

        // Ellipse semi-major and semi-minor axes (half of length and width)
        float a = motionValues[i].z * 0.5; // Semi-major axis
        float b = motionValues[i].w * 0.5; // Semi-minor axis

        // Transform the offset to the ellipse's local space and rotate it for pixel check
        float cosTheta = cos(positionValues[i].w);
        float sinTheta = sin(positionValues[i].w);
        float2 localOffset;
        localOffset.x = offset.x * cosTheta + offset.y * sinTheta;
        localOffset.y = -offset.x * sinTheta + offset.y * cosTheta;
        float ellipseEquation = (localOffset.x * localOffset.x) / (a * a) + (localOffset.y * localOffset.y) / (b * b);

        if (ellipseEquation <= 1.0)
        {
            float top = positionValues[i].y + (motionValues[i].y * 0.5);
            float bottom = positionValues[i].y - (motionValues[i].y * 0.5);
            color = lerp(color, float4(motionValues[i].x, bottom, positionValues[i].w, top), 0.25);
            //color.a = positionValues[i].y;
        }
    }
    ResultArray[uint3(id.xyz)] = color;
}
